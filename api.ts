/* tslint:disable */
/* eslint-disable */
/**
 * ColiVara
 * Colivara is a suite of services that allows you to store, search, and retrieve documents based on their visual embeddings.      It is a web-first implementation of the ColPali paper using ColQwen2 as backend model. It works exacly like RAG from the end-user standpoint - but using vision models instead of chunking and text-processing for documents.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@colivara.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CollectionIn
 */
export interface CollectionIn {
    /**
     * 
     * @type {string}
     * @memberof CollectionIn
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof CollectionIn
     */
    'metadata'?: object | null;
}
/**
 * 
 * @export
 * @interface CollectionOut
 */
export interface CollectionOut {
    /**
     * 
     * @type {number}
     * @memberof CollectionOut
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CollectionOut
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof CollectionOut
     */
    'metadata': object;
    /**
     * 
     * @type {number}
     * @memberof CollectionOut
     */
    'num_documents': number;
}
/**
 * 
 * @export
 * @interface DocumentIn
 */
export interface DocumentIn {
    /**
     * 
     * @type {string}
     * @memberof DocumentIn
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof DocumentIn
     */
    'metadata'?: object;
    /**
     * The name of the collection to which the document belongs. If not provided, the document will be added to the default_collection. Use \'all\' to access all collections belonging to the user.
     * @type {string}
     * @memberof DocumentIn
     */
    'collection_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentIn
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentIn
     */
    'base64'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentIn
     */
    'wait'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentIn
     */
    'use_proxy'?: boolean | null;
}
/**
 * 
 * @export
 * @interface DocumentInPatch
 */
export interface DocumentInPatch {
    /**
     * 
     * @type {string}
     * @memberof DocumentInPatch
     */
    'name'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof DocumentInPatch
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentInPatch
     */
    'collection_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentInPatch
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentInPatch
     */
    'base64'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentInPatch
     */
    'use_proxy'?: boolean | null;
}
/**
 * 
 * @export
 * @interface DocumentOut
 */
export interface DocumentOut {
    /**
     * 
     * @type {number}
     * @memberof DocumentOut
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentOut
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof DocumentOut
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof DocumentOut
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentOut
     */
    'num_pages': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentOut
     */
    'collection_name': string;
    /**
     * 
     * @type {Array<PageOut>}
     * @memberof DocumentOut
     */
    'pages'?: Array<PageOut> | null;
}
/**
 * 
 * @export
 * @interface EmbeddingsIn
 */
export interface EmbeddingsIn {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmbeddingsIn
     */
    'input_data': Array<string>;
    /**
     * 
     * @type {TaskEnum}
     * @memberof EmbeddingsIn
     */
    'task': TaskEnum;
}


/**
 * 
 * @export
 * @interface EmbeddingsOut
 */
export interface EmbeddingsOut {
    /**
     * 
     * @type {Array<object>}
     * @memberof EmbeddingsOut
     */
    'data': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof EmbeddingsOut
     */
    'model': string;
    /**
     * 
     * @type {object}
     * @memberof EmbeddingsOut
     */
    'usage': object;
}
/**
 * 
 * @export
 * @interface FileOut
 */
export interface FileOut {
    /**
     * 
     * @type {string}
     * @memberof FileOut
     */
    'img_base64': string;
    /**
     * 
     * @type {number}
     * @memberof FileOut
     */
    'page_number': number;
}
/**
 * 
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface GenericMessage
 */
export interface GenericMessage {
    /**
     * 
     * @type {string}
     * @memberof GenericMessage
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LookupEnum = {
    KeyLookup: 'key_lookup',
    Contains: 'contains',
    ContainedBy: 'contained_by',
    HasKey: 'has_key',
    HasKeys: 'has_keys',
    HasAnyKeys: 'has_any_keys'
} as const;

export type LookupEnum = typeof LookupEnum[keyof typeof LookupEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const OnEnum = {
    Document: 'document',
    Collection: 'collection'
} as const;

export type OnEnum = typeof OnEnum[keyof typeof OnEnum];


/**
 * 
 * @export
 * @interface PageOut
 */
export interface PageOut {
    /**
     * 
     * @type {string}
     * @memberof PageOut
     */
    'document_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PageOut
     */
    'img_base64': string;
    /**
     * 
     * @type {number}
     * @memberof PageOut
     */
    'page_number': number;
}
/**
 * 
 * @export
 * @interface PageOutQuery
 */
export interface PageOutQuery {
    /**
     * 
     * @type {string}
     * @memberof PageOutQuery
     */
    'collection_name': string;
    /**
     * 
     * @type {number}
     * @memberof PageOutQuery
     */
    'collection_id': number;
    /**
     * 
     * @type {object}
     * @memberof PageOutQuery
     */
    'collection_metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof PageOutQuery
     */
    'document_name': string;
    /**
     * 
     * @type {number}
     * @memberof PageOutQuery
     */
    'document_id': number;
    /**
     * 
     * @type {object}
     * @memberof PageOutQuery
     */
    'document_metadata'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof PageOutQuery
     */
    'page_number': number;
    /**
     * 
     * @type {number}
     * @memberof PageOutQuery
     */
    'raw_score': number;
    /**
     * 
     * @type {number}
     * @memberof PageOutQuery
     */
    'normalized_score': number;
    /**
     * 
     * @type {string}
     * @memberof PageOutQuery
     */
    'img_base64': string;
}
/**
 * 
 * @export
 * @interface PatchCollectionIn
 */
export interface PatchCollectionIn {
    /**
     * 
     * @type {string}
     * @memberof PatchCollectionIn
     */
    'name'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof PatchCollectionIn
     */
    'metadata'?: object | null;
}
/**
 * 
 * @export
 * @interface QueryFilter
 */
export interface QueryFilter {
    /**
     * 
     * @type {OnEnum}
     * @memberof QueryFilter
     */
    'on'?: OnEnum;
    /**
     * 
     * @type {Key}
     * @memberof QueryFilter
     */
    'key': Key;
    /**
     * 
     * @type {Value}
     * @memberof QueryFilter
     */
    'value'?: Value | null;
    /**
     * 
     * @type {LookupEnum}
     * @memberof QueryFilter
     */
    'lookup'?: LookupEnum;
}


/**
 * 
 * @export
 * @interface QueryIn
 */
export interface QueryIn {
    /**
     * 
     * @type {string}
     * @memberof QueryIn
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof QueryIn
     */
    'collection_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof QueryIn
     */
    'top_k'?: number | null;
    /**
     * 
     * @type {QueryFilter}
     * @memberof QueryIn
     */
    'query_filter'?: QueryFilter | null;
}
/**
 * 
 * @export
 * @interface QueryOut
 */
export interface QueryOut {
    /**
     * 
     * @type {string}
     * @memberof QueryOut
     */
    'query': string;
    /**
     * 
     * @type {Array<PageOutQuery>}
     * @memberof QueryOut
     */
    'results': Array<PageOutQuery>;
}
/**
 * 
 * @export
 * @interface Response
 */
export interface Response {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TaskEnum = {
    Image: 'image',
    Query: 'query'
} as const;

export type TaskEnum = typeof TaskEnum[keyof typeof TaskEnum];


/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
}
/**
 * 
 * @export
 * @interface WebhookIn
 */
export interface WebhookIn {
    /**
     * 
     * @type {string}
     * @memberof WebhookIn
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface WebhookOut
 */
export interface WebhookOut {
    /**
     * 
     * @type {string}
     * @memberof WebhookOut
     */
    'app_id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookOut
     */
    'endpoint_id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookOut
     */
    'webhook_secret': string;
}

/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new collection.  This endpoint allows the user to create a new collection with the specified name and metadata.  Args:     request: The HTTP request object, which includes the user information.     payload (CollectionIn): The input data for creating the collection, which includes the name and metadata.  Returns:     dict: A dictionary containing the ID of the newly created collection and a success message.  Raises:     HttpError: If the user already has a collection with the same name.
         * @summary Create Collection
         * @param {CollectionIn} collectionIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsCreateCollection: async (collectionIn: CollectionIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionIn' is not null or undefined
            assertParamExists('apiViewsCreateCollection', 'collectionIn', collectionIn)
            const localVarPath = `/v1/collections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a collection by its name.  This endpoint deletes a collection specified by the `collection_name` parameter. The collection must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_id (int): The ID of the collection to be deleted.  Returns:     dict: A message indicating that the collection was deleted successfully.  Raises:     HTTPException: If the collection does not exist or does not belong to the authenticated user.
         * @summary Delete Collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsDeleteCollection: async (collectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('apiViewsDeleteCollection', 'collectionName', collectionName)
            const localVarPath = `/v1/collections/{collection_name}/`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection by its name.  Args:     request: The request object containing authentication information.     collection_name (str): The name of the collection to retrieve.  Returns:     CollectionOut: The retrieved collection with its ID, name, and metadata.  Raises:     HTTPException: If the collection is not found or the user is not authorized to access it.  Endpoint:     GET /collections/{collection_name}  Tags:     collections  Authentication:     Bearer token required.
         * @summary Get Collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsGetCollection: async (collectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('apiViewsGetCollection', 'collectionName', collectionName)
            const localVarPath = `/v1/collections/{collection_name}/`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint to list collections.  This endpoint retrieves a list of collections owned by the authenticated user.  Args:     request: The request object containing authentication information.  Returns:     A list of CollectionOut objects representing the collections owned by the authenticated user.  Raises:     HTTPException: If there is an issue with the request or authentication.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsListCollections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/collections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a collection.  This endpoint allows for partial updates to a collection\'s details. Only the fields provided in the payload will be updated.  Args:     request: The request object containing authentication details.     collection_name (str): The name of the collection to be updated.     payload (PatchCollectionIn): The payload containing the fields to be updated.  Returns:     dict: A message indicating the collection was updated successfully.  Raises:     HTTPException: If the collection is not found or the user is not authorized to update it.
         * @summary Partial Update Collection
         * @param {string} collectionName 
         * @param {PatchCollectionIn} patchCollectionIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsPartialUpdateCollection: async (collectionName: string, patchCollectionIn: PatchCollectionIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('apiViewsPartialUpdateCollection', 'collectionName', collectionName)
            // verify required parameter 'patchCollectionIn' is not null or undefined
            assertParamExists('apiViewsPartialUpdateCollection', 'patchCollectionIn', patchCollectionIn)
            const localVarPath = `/v1/collections/{collection_name}/`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchCollectionIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new collection.  This endpoint allows the user to create a new collection with the specified name and metadata.  Args:     request: The HTTP request object, which includes the user information.     payload (CollectionIn): The input data for creating the collection, which includes the name and metadata.  Returns:     dict: A dictionary containing the ID of the newly created collection and a success message.  Raises:     HttpError: If the user already has a collection with the same name.
         * @summary Create Collection
         * @param {CollectionIn} collectionIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsCreateCollection(collectionIn: CollectionIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsCreateCollection(collectionIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.apiViewsCreateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a collection by its name.  This endpoint deletes a collection specified by the `collection_name` parameter. The collection must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_id (int): The ID of the collection to be deleted.  Returns:     dict: A message indicating that the collection was deleted successfully.  Raises:     HTTPException: If the collection does not exist or does not belong to the authenticated user.
         * @summary Delete Collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsDeleteCollection(collectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsDeleteCollection(collectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.apiViewsDeleteCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a collection by its name.  Args:     request: The request object containing authentication information.     collection_name (str): The name of the collection to retrieve.  Returns:     CollectionOut: The retrieved collection with its ID, name, and metadata.  Raises:     HTTPException: If the collection is not found or the user is not authorized to access it.  Endpoint:     GET /collections/{collection_name}  Tags:     collections  Authentication:     Bearer token required.
         * @summary Get Collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsGetCollection(collectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsGetCollection(collectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.apiViewsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint to list collections.  This endpoint retrieves a list of collections owned by the authenticated user.  Args:     request: The request object containing authentication information.  Returns:     A list of CollectionOut objects representing the collections owned by the authenticated user.  Raises:     HTTPException: If there is an issue with the request or authentication.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsListCollections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CollectionOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsListCollections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.apiViewsListCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a collection.  This endpoint allows for partial updates to a collection\'s details. Only the fields provided in the payload will be updated.  Args:     request: The request object containing authentication details.     collection_name (str): The name of the collection to be updated.     payload (PatchCollectionIn): The payload containing the fields to be updated.  Returns:     dict: A message indicating the collection was updated successfully.  Raises:     HTTPException: If the collection is not found or the user is not authorized to update it.
         * @summary Partial Update Collection
         * @param {string} collectionName 
         * @param {PatchCollectionIn} patchCollectionIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsPartialUpdateCollection(collectionName: string, patchCollectionIn: PatchCollectionIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsPartialUpdateCollection(collectionName, patchCollectionIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.apiViewsPartialUpdateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * Create a new collection.  This endpoint allows the user to create a new collection with the specified name and metadata.  Args:     request: The HTTP request object, which includes the user information.     payload (CollectionIn): The input data for creating the collection, which includes the name and metadata.  Returns:     dict: A dictionary containing the ID of the newly created collection and a success message.  Raises:     HttpError: If the user already has a collection with the same name.
         * @summary Create Collection
         * @param {CollectionIn} collectionIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsCreateCollection(collectionIn: CollectionIn, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOut> {
            return localVarFp.apiViewsCreateCollection(collectionIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a collection by its name.  This endpoint deletes a collection specified by the `collection_name` parameter. The collection must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_id (int): The ID of the collection to be deleted.  Returns:     dict: A message indicating that the collection was deleted successfully.  Raises:     HTTPException: If the collection does not exist or does not belong to the authenticated user.
         * @summary Delete Collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsDeleteCollection(collectionName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiViewsDeleteCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection by its name.  Args:     request: The request object containing authentication information.     collection_name (str): The name of the collection to retrieve.  Returns:     CollectionOut: The retrieved collection with its ID, name, and metadata.  Raises:     HTTPException: If the collection is not found or the user is not authorized to access it.  Endpoint:     GET /collections/{collection_name}  Tags:     collections  Authentication:     Bearer token required.
         * @summary Get Collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsGetCollection(collectionName: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOut> {
            return localVarFp.apiViewsGetCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint to list collections.  This endpoint retrieves a list of collections owned by the authenticated user.  Args:     request: The request object containing authentication information.  Returns:     A list of CollectionOut objects representing the collections owned by the authenticated user.  Raises:     HTTPException: If there is an issue with the request or authentication.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsListCollections(options?: RawAxiosRequestConfig): AxiosPromise<Array<CollectionOut>> {
            return localVarFp.apiViewsListCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a collection.  This endpoint allows for partial updates to a collection\'s details. Only the fields provided in the payload will be updated.  Args:     request: The request object containing authentication details.     collection_name (str): The name of the collection to be updated.     payload (PatchCollectionIn): The payload containing the fields to be updated.  Returns:     dict: A message indicating the collection was updated successfully.  Raises:     HTTPException: If the collection is not found or the user is not authorized to update it.
         * @summary Partial Update Collection
         * @param {string} collectionName 
         * @param {PatchCollectionIn} patchCollectionIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsPartialUpdateCollection(collectionName: string, patchCollectionIn: PatchCollectionIn, options?: RawAxiosRequestConfig): AxiosPromise<CollectionOut> {
            return localVarFp.apiViewsPartialUpdateCollection(collectionName, patchCollectionIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Create a new collection.  This endpoint allows the user to create a new collection with the specified name and metadata.  Args:     request: The HTTP request object, which includes the user information.     payload (CollectionIn): The input data for creating the collection, which includes the name and metadata.  Returns:     dict: A dictionary containing the ID of the newly created collection and a success message.  Raises:     HttpError: If the user already has a collection with the same name.
     * @summary Create Collection
     * @param {CollectionIn} collectionIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public apiViewsCreateCollection(collectionIn: CollectionIn, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).apiViewsCreateCollection(collectionIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a collection by its name.  This endpoint deletes a collection specified by the `collection_name` parameter. The collection must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_id (int): The ID of the collection to be deleted.  Returns:     dict: A message indicating that the collection was deleted successfully.  Raises:     HTTPException: If the collection does not exist or does not belong to the authenticated user.
     * @summary Delete Collection
     * @param {string} collectionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public apiViewsDeleteCollection(collectionName: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).apiViewsDeleteCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection by its name.  Args:     request: The request object containing authentication information.     collection_name (str): The name of the collection to retrieve.  Returns:     CollectionOut: The retrieved collection with its ID, name, and metadata.  Raises:     HTTPException: If the collection is not found or the user is not authorized to access it.  Endpoint:     GET /collections/{collection_name}  Tags:     collections  Authentication:     Bearer token required.
     * @summary Get Collection
     * @param {string} collectionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public apiViewsGetCollection(collectionName: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).apiViewsGetCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint to list collections.  This endpoint retrieves a list of collections owned by the authenticated user.  Args:     request: The request object containing authentication information.  Returns:     A list of CollectionOut objects representing the collections owned by the authenticated user.  Raises:     HTTPException: If there is an issue with the request or authentication.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public apiViewsListCollections(options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).apiViewsListCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a collection.  This endpoint allows for partial updates to a collection\'s details. Only the fields provided in the payload will be updated.  Args:     request: The request object containing authentication details.     collection_name (str): The name of the collection to be updated.     payload (PatchCollectionIn): The payload containing the fields to be updated.  Returns:     dict: A message indicating the collection was updated successfully.  Raises:     HTTPException: If the collection is not found or the user is not authorized to update it.
     * @summary Partial Update Collection
     * @param {string} collectionName 
     * @param {PatchCollectionIn} patchCollectionIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public apiViewsPartialUpdateCollection(collectionName: string, patchCollectionIn: PatchCollectionIn, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).apiViewsPartialUpdateCollection(collectionName, patchCollectionIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a document by its Name.  This endpoint deletes a document specified by the `document_name` parameter. The document must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_name (name): The name of the collection containing the document. Defaults to \"default_collection\". Use \"all\" to access all collections belonging to the user.     document_name (int): The name of the document to be deleted.  Returns:     dict: A message indicating that the document was deleted successfully.  Raises:     HTTPException: If the document does not exist or does not belong to the authenticated user.  Example:     DELETE /documents/delete-document/{document_name}/?collection_name={collection_name}
         * @summary Delete Document
         * @param {string} documentName 
         * @param {string | null} [collectionName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsDeleteDocument: async (documentName: string, collectionName?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentName' is not null or undefined
            assertParamExists('apiViewsDeleteDocument', 'documentName', documentName)
            const localVarPath = `/v1/documents/delete-document/{document_name}/`
                .replace(`{${"document_name"}}`, encodeURIComponent(String(documentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (collectionName !== undefined) {
                localVarQueryParameter['collection_name'] = collectionName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific document from the user documents. Default collection is \"default_collection\". To get all documents, use collection_name=\"all\".  Args:     request: The HTTP request object.     document_name (str): The ID of the document to retrieve.     expand (Optional[str]): A comma-separated list of fields to expand in the response.                             If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved document with its details.  Raises:     HTTPException: If the document or collection is not found.  Example:     GET /documents/{document_name}/?collection_name={collection_name}&expand=pages
         * @summary Get Document
         * @param {string} documentName 
         * @param {string | null} [collectionName] 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsGetDocument: async (documentName: string, collectionName?: string | null, expand?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentName' is not null or undefined
            assertParamExists('apiViewsGetDocument', 'documentName', documentName)
            const localVarPath = `/v1/documents/{document_name}/`
                .replace(`{${"document_name"}}`, encodeURIComponent(String(documentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (collectionName !== undefined) {
                localVarQueryParameter['collection_name'] = collectionName;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of documents for a given collection.  This endpoint retrieves documents associated with a specified collection name. Optionally, it can expand the response to include pages of each document.  Args:     request (Request): The request object.     collection_name (Optional[str]): The name of the collection to fetch documents from. Defaults to \"default_collection\". Use \"all\" to fetch documents from all collections.     expand (Optional[str]): A comma-separated string specifying additional fields to include in the response.                             If \"pages\" is included, the pages of each document will be included.  Returns:     List[DocumentOut]: A list of documents with their details. If expanded, includes pages of each document.  Raises:     HTTPException: If the collection or documents are not found.  Example:     GET /documents/?collection_name=default_collection&expand=pages
         * @summary List Documents
         * @param {string | null} [collectionName] 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsListDocuments: async (collectionName?: string | null, expand?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (collectionName !== undefined) {
                localVarQueryParameter['collection_name'] = collectionName;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a document.  This endpoint allows for partial updates to a document\'s details. Only the fields provided in the payload will be updated. If the URL is changed or base64 is provided, the document will be re-embedded. Otherwise, only the metadata and name will be updated.  Args:     request: The request object containing authentication details.     document_name (str): The name of the document to be updated.     payload (DocumentInPatch): The payload containing the fields to be updated.  Returns:     Tuple[int, DocumentOut] | Tuple[int, GenericError]: A tuple containing the status code and the updated document or an error message.  Raises:     HTTPException: If the document is not found or the user is not authorized to update it.
         * @summary Partial Update Document
         * @param {string} documentName 
         * @param {DocumentInPatch} documentInPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsPartialUpdateDocument: async (documentName: string, documentInPatch: DocumentInPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentName' is not null or undefined
            assertParamExists('apiViewsPartialUpdateDocument', 'documentName', documentName)
            // verify required parameter 'documentInPatch' is not null or undefined
            assertParamExists('apiViewsPartialUpdateDocument', 'documentInPatch', documentInPatch)
            const localVarPath = `/v1/documents/{document_name}/`
                .replace(`{${"document_name"}}`, encodeURIComponent(String(documentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentInPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a document in a collection. Average latency is 7 seconds per page.  This endpoint allows the user to create or update a document in a collection. The document can be provided as a URL or a base64-encoded string. if the collection is not provided, a collection named \"default_collection\" will be used. if the collection is provided, it will be created if it does not exist.  Args:     request: The HTTP request object, which includes the user information.     payload (DocumentIn): The input data for creating or updating the document.  Returns:     str: A message indicating that the document is being processed.  Raises:     HttpError: If the document cannot be created or updated.  Example:     POST /documents/upsert-document/     {         \"name\": \"my_document\",         \"metadata\": {\"author\": \"John Doe\"},         \"collection\": \"my_collection\",         \"url\": \"https://example.com/my_document.pdf,         \"wait\": true # optional, if true, the response will be sent after waiting for the document to be processed. Otherwise, it will be done asynchronously.     }
         * @summary Upsert Document
         * @param {DocumentIn} documentIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsUpsertDocument: async (documentIn: DocumentIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentIn' is not null or undefined
            assertParamExists('apiViewsUpsertDocument', 'documentIn', documentIn)
            const localVarPath = `/v1/documents/upsert-document/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a document by its Name.  This endpoint deletes a document specified by the `document_name` parameter. The document must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_name (name): The name of the collection containing the document. Defaults to \"default_collection\". Use \"all\" to access all collections belonging to the user.     document_name (int): The name of the document to be deleted.  Returns:     dict: A message indicating that the document was deleted successfully.  Raises:     HTTPException: If the document does not exist or does not belong to the authenticated user.  Example:     DELETE /documents/delete-document/{document_name}/?collection_name={collection_name}
         * @summary Delete Document
         * @param {string} documentName 
         * @param {string | null} [collectionName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsDeleteDocument(documentName: string, collectionName?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsDeleteDocument(documentName, collectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.apiViewsDeleteDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific document from the user documents. Default collection is \"default_collection\". To get all documents, use collection_name=\"all\".  Args:     request: The HTTP request object.     document_name (str): The ID of the document to retrieve.     expand (Optional[str]): A comma-separated list of fields to expand in the response.                             If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved document with its details.  Raises:     HTTPException: If the document or collection is not found.  Example:     GET /documents/{document_name}/?collection_name={collection_name}&expand=pages
         * @summary Get Document
         * @param {string} documentName 
         * @param {string | null} [collectionName] 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsGetDocument(documentName: string, collectionName?: string | null, expand?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsGetDocument(documentName, collectionName, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.apiViewsGetDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of documents for a given collection.  This endpoint retrieves documents associated with a specified collection name. Optionally, it can expand the response to include pages of each document.  Args:     request (Request): The request object.     collection_name (Optional[str]): The name of the collection to fetch documents from. Defaults to \"default_collection\". Use \"all\" to fetch documents from all collections.     expand (Optional[str]): A comma-separated string specifying additional fields to include in the response.                             If \"pages\" is included, the pages of each document will be included.  Returns:     List[DocumentOut]: A list of documents with their details. If expanded, includes pages of each document.  Raises:     HTTPException: If the collection or documents are not found.  Example:     GET /documents/?collection_name=default_collection&expand=pages
         * @summary List Documents
         * @param {string | null} [collectionName] 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsListDocuments(collectionName?: string | null, expand?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsListDocuments(collectionName, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.apiViewsListDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a document.  This endpoint allows for partial updates to a document\'s details. Only the fields provided in the payload will be updated. If the URL is changed or base64 is provided, the document will be re-embedded. Otherwise, only the metadata and name will be updated.  Args:     request: The request object containing authentication details.     document_name (str): The name of the document to be updated.     payload (DocumentInPatch): The payload containing the fields to be updated.  Returns:     Tuple[int, DocumentOut] | Tuple[int, GenericError]: A tuple containing the status code and the updated document or an error message.  Raises:     HTTPException: If the document is not found or the user is not authorized to update it.
         * @summary Partial Update Document
         * @param {string} documentName 
         * @param {DocumentInPatch} documentInPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsPartialUpdateDocument(documentName: string, documentInPatch: DocumentInPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsPartialUpdateDocument(documentName, documentInPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.apiViewsPartialUpdateDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update a document in a collection. Average latency is 7 seconds per page.  This endpoint allows the user to create or update a document in a collection. The document can be provided as a URL or a base64-encoded string. if the collection is not provided, a collection named \"default_collection\" will be used. if the collection is provided, it will be created if it does not exist.  Args:     request: The HTTP request object, which includes the user information.     payload (DocumentIn): The input data for creating or updating the document.  Returns:     str: A message indicating that the document is being processed.  Raises:     HttpError: If the document cannot be created or updated.  Example:     POST /documents/upsert-document/     {         \"name\": \"my_document\",         \"metadata\": {\"author\": \"John Doe\"},         \"collection\": \"my_collection\",         \"url\": \"https://example.com/my_document.pdf,         \"wait\": true # optional, if true, the response will be sent after waiting for the document to be processed. Otherwise, it will be done asynchronously.     }
         * @summary Upsert Document
         * @param {DocumentIn} documentIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsUpsertDocument(documentIn: DocumentIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsUpsertDocument(documentIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.apiViewsUpsertDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Delete a document by its Name.  This endpoint deletes a document specified by the `document_name` parameter. The document must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_name (name): The name of the collection containing the document. Defaults to \"default_collection\". Use \"all\" to access all collections belonging to the user.     document_name (int): The name of the document to be deleted.  Returns:     dict: A message indicating that the document was deleted successfully.  Raises:     HTTPException: If the document does not exist or does not belong to the authenticated user.  Example:     DELETE /documents/delete-document/{document_name}/?collection_name={collection_name}
         * @summary Delete Document
         * @param {string} documentName 
         * @param {string | null} [collectionName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsDeleteDocument(documentName: string, collectionName?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiViewsDeleteDocument(documentName, collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific document from the user documents. Default collection is \"default_collection\". To get all documents, use collection_name=\"all\".  Args:     request: The HTTP request object.     document_name (str): The ID of the document to retrieve.     expand (Optional[str]): A comma-separated list of fields to expand in the response.                             If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved document with its details.  Raises:     HTTPException: If the document or collection is not found.  Example:     GET /documents/{document_name}/?collection_name={collection_name}&expand=pages
         * @summary Get Document
         * @param {string} documentName 
         * @param {string | null} [collectionName] 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsGetDocument(documentName: string, collectionName?: string | null, expand?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<DocumentOut> {
            return localVarFp.apiViewsGetDocument(documentName, collectionName, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of documents for a given collection.  This endpoint retrieves documents associated with a specified collection name. Optionally, it can expand the response to include pages of each document.  Args:     request (Request): The request object.     collection_name (Optional[str]): The name of the collection to fetch documents from. Defaults to \"default_collection\". Use \"all\" to fetch documents from all collections.     expand (Optional[str]): A comma-separated string specifying additional fields to include in the response.                             If \"pages\" is included, the pages of each document will be included.  Returns:     List[DocumentOut]: A list of documents with their details. If expanded, includes pages of each document.  Raises:     HTTPException: If the collection or documents are not found.  Example:     GET /documents/?collection_name=default_collection&expand=pages
         * @summary List Documents
         * @param {string | null} [collectionName] 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsListDocuments(collectionName?: string | null, expand?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentOut>> {
            return localVarFp.apiViewsListDocuments(collectionName, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a document.  This endpoint allows for partial updates to a document\'s details. Only the fields provided in the payload will be updated. If the URL is changed or base64 is provided, the document will be re-embedded. Otherwise, only the metadata and name will be updated.  Args:     request: The request object containing authentication details.     document_name (str): The name of the document to be updated.     payload (DocumentInPatch): The payload containing the fields to be updated.  Returns:     Tuple[int, DocumentOut] | Tuple[int, GenericError]: A tuple containing the status code and the updated document or an error message.  Raises:     HTTPException: If the document is not found or the user is not authorized to update it.
         * @summary Partial Update Document
         * @param {string} documentName 
         * @param {DocumentInPatch} documentInPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsPartialUpdateDocument(documentName: string, documentInPatch: DocumentInPatch, options?: RawAxiosRequestConfig): AxiosPromise<DocumentOut> {
            return localVarFp.apiViewsPartialUpdateDocument(documentName, documentInPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a document in a collection. Average latency is 7 seconds per page.  This endpoint allows the user to create or update a document in a collection. The document can be provided as a URL or a base64-encoded string. if the collection is not provided, a collection named \"default_collection\" will be used. if the collection is provided, it will be created if it does not exist.  Args:     request: The HTTP request object, which includes the user information.     payload (DocumentIn): The input data for creating or updating the document.  Returns:     str: A message indicating that the document is being processed.  Raises:     HttpError: If the document cannot be created or updated.  Example:     POST /documents/upsert-document/     {         \"name\": \"my_document\",         \"metadata\": {\"author\": \"John Doe\"},         \"collection\": \"my_collection\",         \"url\": \"https://example.com/my_document.pdf,         \"wait\": true # optional, if true, the response will be sent after waiting for the document to be processed. Otherwise, it will be done asynchronously.     }
         * @summary Upsert Document
         * @param {DocumentIn} documentIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsUpsertDocument(documentIn: DocumentIn, options?: RawAxiosRequestConfig): AxiosPromise<DocumentOut> {
            return localVarFp.apiViewsUpsertDocument(documentIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Delete a document by its Name.  This endpoint deletes a document specified by the `document_name` parameter. The document must belong to the authenticated user.  Args:     request: The HTTP request object, which includes authentication information.     collection_name (name): The name of the collection containing the document. Defaults to \"default_collection\". Use \"all\" to access all collections belonging to the user.     document_name (int): The name of the document to be deleted.  Returns:     dict: A message indicating that the document was deleted successfully.  Raises:     HTTPException: If the document does not exist or does not belong to the authenticated user.  Example:     DELETE /documents/delete-document/{document_name}/?collection_name={collection_name}
     * @summary Delete Document
     * @param {string} documentName 
     * @param {string | null} [collectionName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiViewsDeleteDocument(documentName: string, collectionName?: string | null, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).apiViewsDeleteDocument(documentName, collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific document from the user documents. Default collection is \"default_collection\". To get all documents, use collection_name=\"all\".  Args:     request: The HTTP request object.     document_name (str): The ID of the document to retrieve.     expand (Optional[str]): A comma-separated list of fields to expand in the response.                             If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved document with its details.  Raises:     HTTPException: If the document or collection is not found.  Example:     GET /documents/{document_name}/?collection_name={collection_name}&expand=pages
     * @summary Get Document
     * @param {string} documentName 
     * @param {string | null} [collectionName] 
     * @param {string | null} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiViewsGetDocument(documentName: string, collectionName?: string | null, expand?: string | null, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).apiViewsGetDocument(documentName, collectionName, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of documents for a given collection.  This endpoint retrieves documents associated with a specified collection name. Optionally, it can expand the response to include pages of each document.  Args:     request (Request): The request object.     collection_name (Optional[str]): The name of the collection to fetch documents from. Defaults to \"default_collection\". Use \"all\" to fetch documents from all collections.     expand (Optional[str]): A comma-separated string specifying additional fields to include in the response.                             If \"pages\" is included, the pages of each document will be included.  Returns:     List[DocumentOut]: A list of documents with their details. If expanded, includes pages of each document.  Raises:     HTTPException: If the collection or documents are not found.  Example:     GET /documents/?collection_name=default_collection&expand=pages
     * @summary List Documents
     * @param {string | null} [collectionName] 
     * @param {string | null} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiViewsListDocuments(collectionName?: string | null, expand?: string | null, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).apiViewsListDocuments(collectionName, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a document.  This endpoint allows for partial updates to a document\'s details. Only the fields provided in the payload will be updated. If the URL is changed or base64 is provided, the document will be re-embedded. Otherwise, only the metadata and name will be updated.  Args:     request: The request object containing authentication details.     document_name (str): The name of the document to be updated.     payload (DocumentInPatch): The payload containing the fields to be updated.  Returns:     Tuple[int, DocumentOut] | Tuple[int, GenericError]: A tuple containing the status code and the updated document or an error message.  Raises:     HTTPException: If the document is not found or the user is not authorized to update it.
     * @summary Partial Update Document
     * @param {string} documentName 
     * @param {DocumentInPatch} documentInPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiViewsPartialUpdateDocument(documentName: string, documentInPatch: DocumentInPatch, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).apiViewsPartialUpdateDocument(documentName, documentInPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a document in a collection. Average latency is 7 seconds per page.  This endpoint allows the user to create or update a document in a collection. The document can be provided as a URL or a base64-encoded string. if the collection is not provided, a collection named \"default_collection\" will be used. if the collection is provided, it will be created if it does not exist.  Args:     request: The HTTP request object, which includes the user information.     payload (DocumentIn): The input data for creating or updating the document.  Returns:     str: A message indicating that the document is being processed.  Raises:     HttpError: If the document cannot be created or updated.  Example:     POST /documents/upsert-document/     {         \"name\": \"my_document\",         \"metadata\": {\"author\": \"John Doe\"},         \"collection\": \"my_collection\",         \"url\": \"https://example.com/my_document.pdf,         \"wait\": true # optional, if true, the response will be sent after waiting for the document to be processed. Otherwise, it will be done asynchronously.     }
     * @summary Upsert Document
     * @param {DocumentIn} documentIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public apiViewsUpsertDocument(documentIn: DocumentIn, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).apiViewsUpsertDocument(documentIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmbeddingsApi - axios parameter creator
 * @export
 */
export const EmbeddingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Embed a list of documents.  This endpoint allows the user to embed a list of documents.  Args:     request: The HTTP request object, which includes the user information.     payload (EmbeddingsIn): The input data for embedding the documents.  Returns:     EmbeddingsOut: The embeddings of the documents and metadata.  Raises:     HttpError: If the documents cannot be embedded.
         * @summary Embeddings
         * @param {EmbeddingsIn} embeddingsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsEmbeddings: async (embeddingsIn: EmbeddingsIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'embeddingsIn' is not null or undefined
            assertParamExists('apiViewsEmbeddings', 'embeddingsIn', embeddingsIn)
            const localVarPath = `/v1/embeddings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(embeddingsIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmbeddingsApi - functional programming interface
 * @export
 */
export const EmbeddingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmbeddingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Embed a list of documents.  This endpoint allows the user to embed a list of documents.  Args:     request: The HTTP request object, which includes the user information.     payload (EmbeddingsIn): The input data for embedding the documents.  Returns:     EmbeddingsOut: The embeddings of the documents and metadata.  Raises:     HttpError: If the documents cannot be embedded.
         * @summary Embeddings
         * @param {EmbeddingsIn} embeddingsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsEmbeddings(embeddingsIn: EmbeddingsIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbeddingsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsEmbeddings(embeddingsIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbeddingsApi.apiViewsEmbeddings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmbeddingsApi - factory interface
 * @export
 */
export const EmbeddingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmbeddingsApiFp(configuration)
    return {
        /**
         * Embed a list of documents.  This endpoint allows the user to embed a list of documents.  Args:     request: The HTTP request object, which includes the user information.     payload (EmbeddingsIn): The input data for embedding the documents.  Returns:     EmbeddingsOut: The embeddings of the documents and metadata.  Raises:     HttpError: If the documents cannot be embedded.
         * @summary Embeddings
         * @param {EmbeddingsIn} embeddingsIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsEmbeddings(embeddingsIn: EmbeddingsIn, options?: RawAxiosRequestConfig): AxiosPromise<EmbeddingsOut> {
            return localVarFp.apiViewsEmbeddings(embeddingsIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmbeddingsApi - object-oriented interface
 * @export
 * @class EmbeddingsApi
 * @extends {BaseAPI}
 */
export class EmbeddingsApi extends BaseAPI {
    /**
     * Embed a list of documents.  This endpoint allows the user to embed a list of documents.  Args:     request: The HTTP request object, which includes the user information.     payload (EmbeddingsIn): The input data for embedding the documents.  Returns:     EmbeddingsOut: The embeddings of the documents and metadata.  Raises:     HttpError: If the documents cannot be embedded.
     * @summary Embeddings
     * @param {EmbeddingsIn} embeddingsIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddingsApi
     */
    public apiViewsEmbeddings(embeddingsIn: EmbeddingsIn, options?: RawAxiosRequestConfig) {
        return EmbeddingsApiFp(this.configuration).apiViewsEmbeddings(embeddingsIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Filter for documents and collections that meet the criteria of the filter.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryFilter): The input data for the filter, which includes the filter criteria.     expand (Optional[str]): A comma-separated list of fields to expand in the response. If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved documents with their details.     CollectionOut: The retrieved collections with their details.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /filter/?expand=pages     {         \"on\": \"document\",         \"key\": \"breed\",         \"value\": \"collie\",         \"lookup\": \"contains\"     }
         * @summary Filter
         * @param {QueryFilter} queryFilter 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsFilter: async (queryFilter: QueryFilter, expand?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryFilter' is not null or undefined
            assertParamExists('apiViewsFilter', 'queryFilter', queryFilter)
            const localVarPath = `/v1/filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilterApiAxiosParamCreator(configuration)
    return {
        /**
         * Filter for documents and collections that meet the criteria of the filter.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryFilter): The input data for the filter, which includes the filter criteria.     expand (Optional[str]): A comma-separated list of fields to expand in the response. If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved documents with their details.     CollectionOut: The retrieved collections with their details.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /filter/?expand=pages     {         \"on\": \"document\",         \"key\": \"breed\",         \"value\": \"collie\",         \"lookup\": \"contains\"     }
         * @summary Filter
         * @param {QueryFilter} queryFilter 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsFilter(queryFilter: QueryFilter, expand?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsFilter(queryFilter, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilterApi.apiViewsFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilterApiFp(configuration)
    return {
        /**
         * Filter for documents and collections that meet the criteria of the filter.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryFilter): The input data for the filter, which includes the filter criteria.     expand (Optional[str]): A comma-separated list of fields to expand in the response. If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved documents with their details.     CollectionOut: The retrieved collections with their details.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /filter/?expand=pages     {         \"on\": \"document\",         \"key\": \"breed\",         \"value\": \"collie\",         \"lookup\": \"contains\"     }
         * @summary Filter
         * @param {QueryFilter} queryFilter 
         * @param {string | null} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsFilter(queryFilter: QueryFilter, expand?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Response> {
            return localVarFp.apiViewsFilter(queryFilter, expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */
export class FilterApi extends BaseAPI {
    /**
     * Filter for documents and collections that meet the criteria of the filter.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryFilter): The input data for the filter, which includes the filter criteria.     expand (Optional[str]): A comma-separated list of fields to expand in the response. If \"pages\" is included, the document\'s pages will be included.  Returns:     DocumentOut: The retrieved documents with their details.     CollectionOut: The retrieved collections with their details.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /filter/?expand=pages     {         \"on\": \"document\",         \"key\": \"breed\",         \"value\": \"collie\",         \"lookup\": \"contains\"     }
     * @summary Filter
     * @param {QueryFilter} queryFilter 
     * @param {string | null} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public apiViewsFilter(queryFilter: QueryFilter, expand?: string | null, options?: RawAxiosRequestConfig) {
        return FilterApiFp(this.configuration).apiViewsFilter(queryFilter, expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.apiViewsHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiViewsHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiViewsHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).apiViewsHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelpersApi - axios parameter creator
 * @export
 */
export const HelpersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload one file, converts to base64 encoded strings.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns: str: base64 encoded string of the file.
         * @summary File To Base64
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsFileToBase64: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiViewsFileToBase64', 'file', file)
            const localVarPath = `/v1/helpers/file-to-base64/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload one file, converts to images and return their base64 encoded strings with 1-indexed page numberss.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns:     List[FileOut]: A list of FileOut objects containing the base64 encoded strings of the images.
         * @summary File To Imgbase64
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsFileToImgbase64: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiViewsFileToImgbase64', 'file', file)
            const localVarPath = `/v1/helpers/file-to-imgbase64/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelpersApi - functional programming interface
 * @export
 */
export const HelpersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelpersApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload one file, converts to base64 encoded strings.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns: str: base64 encoded string of the file.
         * @summary File To Base64
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsFileToBase64(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsFileToBase64(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelpersApi.apiViewsFileToBase64']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload one file, converts to images and return their base64 encoded strings with 1-indexed page numberss.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns:     List[FileOut]: A list of FileOut objects containing the base64 encoded strings of the images.
         * @summary File To Imgbase64
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsFileToImgbase64(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsFileToImgbase64(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelpersApi.apiViewsFileToImgbase64']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelpersApi - factory interface
 * @export
 */
export const HelpersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelpersApiFp(configuration)
    return {
        /**
         * Upload one file, converts to base64 encoded strings.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns: str: base64 encoded string of the file.
         * @summary File To Base64
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsFileToBase64(file: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiViewsFileToBase64(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload one file, converts to images and return their base64 encoded strings with 1-indexed page numberss.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns:     List[FileOut]: A list of FileOut objects containing the base64 encoded strings of the images.
         * @summary File To Imgbase64
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsFileToImgbase64(file: File, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileOut>> {
            return localVarFp.apiViewsFileToImgbase64(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelpersApi - object-oriented interface
 * @export
 * @class HelpersApi
 * @extends {BaseAPI}
 */
export class HelpersApi extends BaseAPI {
    /**
     * Upload one file, converts to base64 encoded strings.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns: str: base64 encoded string of the file.
     * @summary File To Base64
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpersApi
     */
    public apiViewsFileToBase64(file: File, options?: RawAxiosRequestConfig) {
        return HelpersApiFp(this.configuration).apiViewsFileToBase64(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload one file, converts to images and return their base64 encoded strings with 1-indexed page numberss.  Args:     request: The HTTP request object.     file UploadedFile): One uploaded file  Returns:     List[FileOut]: A list of FileOut objects containing the base64 encoded strings of the images.
     * @summary File To Imgbase64
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpersApi
     */
    public apiViewsFileToImgbase64(file: File, options?: RawAxiosRequestConfig) {
        return HelpersApiFp(this.configuration).apiViewsFileToImgbase64(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for pages similar to a given query.  This endpoint allows the user to search for pages similar to a given query. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryIn): The input data for the search, which includes the query string and collection ID.  Returns:     QueryOut: The search results, including the query and a list of similar pages.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /search/     {         \"query\": \"dog\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search
         * @param {QueryIn} queryIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsSearch: async (queryIn: QueryIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryIn' is not null or undefined
            assertParamExists('apiViewsSearch', 'queryIn', queryIn)
            const localVarPath = `/v1/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Search for pages similar to a given query.  This endpoint allows the user to search for pages similar to a given query. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryIn): The input data for the search, which includes the query string and collection ID.  Returns:     QueryOut: The search results, including the query and a list of similar pages.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /search/     {         \"query\": \"dog\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search
         * @param {QueryIn} queryIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsSearch(queryIn: QueryIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsSearch(queryIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.apiViewsSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Search for pages similar to a given query.  This endpoint allows the user to search for pages similar to a given query. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryIn): The input data for the search, which includes the query string and collection ID.  Returns:     QueryOut: The search results, including the query and a list of similar pages.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /search/     {         \"query\": \"dog\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
         * @summary Search
         * @param {QueryIn} queryIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsSearch(queryIn: QueryIn, options?: RawAxiosRequestConfig): AxiosPromise<QueryOut> {
            return localVarFp.apiViewsSearch(queryIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Search for pages similar to a given query.  This endpoint allows the user to search for pages similar to a given query. The search is performed across all documents in the specified collection.  Args:     request: The HTTP request object, which includes the user information.     payload (QueryIn): The input data for the search, which includes the query string and collection ID.  Returns:     QueryOut: The search results, including the query and a list of similar pages.  Raises:     HttpError: If the collection does not exist or the query is invalid.  Example:     POST /search/     {         \"query\": \"dog\",         \"collection_name\": \"my_collection\",         \"top_k\": 3,         \"query_filter\": {             \"on\": \"document\",             \"key\": \"breed\",             \"value\": \"collie\",             \"lookup\": \"contains\"         }     }
     * @summary Search
     * @param {QueryIn} queryIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public apiViewsSearch(queryIn: QueryIn, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).apiViewsSearch(queryIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a webhook to the service.  This endpoint allows the user to add a webhook to the service. The webhook will be called when a document is upserted with the upsertion status.  Events are document upsert successful, document upsert failed.  Args:     request: The HTTP request object, which includes the user information.     url (str): The URL of the webhook.  Returns:     A message indicating that the webhook was added successfully.  Raises:     HttpError: If the webhook is invalid.
         * @summary Add Webhook
         * @param {WebhookIn} webhookIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsAddWebhook: async (webhookIn: WebhookIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookIn' is not null or undefined
            assertParamExists('apiViewsAddWebhook', 'webhookIn', webhookIn)
            const localVarPath = `/v1/webhook/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a webhook to the service.  This endpoint allows the user to add a webhook to the service. The webhook will be called when a document is upserted with the upsertion status.  Events are document upsert successful, document upsert failed.  Args:     request: The HTTP request object, which includes the user information.     url (str): The URL of the webhook.  Returns:     A message indicating that the webhook was added successfully.  Raises:     HttpError: If the webhook is invalid.
         * @summary Add Webhook
         * @param {WebhookIn} webhookIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewsAddWebhook(webhookIn: WebhookIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewsAddWebhook(webhookIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiViewsAddWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * Add a webhook to the service.  This endpoint allows the user to add a webhook to the service. The webhook will be called when a document is upserted with the upsertion status.  Events are document upsert successful, document upsert failed.  Args:     request: The HTTP request object, which includes the user information.     url (str): The URL of the webhook.  Returns:     A message indicating that the webhook was added successfully.  Raises:     HttpError: If the webhook is invalid.
         * @summary Add Webhook
         * @param {WebhookIn} webhookIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewsAddWebhook(webhookIn: WebhookIn, options?: RawAxiosRequestConfig): AxiosPromise<WebhookOut> {
            return localVarFp.apiViewsAddWebhook(webhookIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * Add a webhook to the service.  This endpoint allows the user to add a webhook to the service. The webhook will be called when a document is upserted with the upsertion status.  Events are document upsert successful, document upsert failed.  Args:     request: The HTTP request object, which includes the user information.     url (str): The URL of the webhook.  Returns:     A message indicating that the webhook was added successfully.  Raises:     HttpError: If the webhook is invalid.
     * @summary Add Webhook
     * @param {WebhookIn} webhookIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiViewsAddWebhook(webhookIn: WebhookIn, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiViewsAddWebhook(webhookIn, options).then((request) => request(this.axios, this.basePath));
    }
}



